<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û—Å–º–æ—Ç—Ä –¢–° - –°–µ–Ω—Ç—Ä–∞—Å –ò–Ω—à—É—Ä–∞–Ω—Å</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        /* CSS –°—Ç–∏–ª–∏ */
        :root {
            --primary-color: #0055A5;
            --secondary-color: #f4f7f9;
            --text-color: #333;
            --border-color: #e0e0e0;
            --success-color: #4CAF50;
            --error-color: #F44336;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--secondary-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: #fff;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .logo-container img {
            height: 40px;
        }

        .logo-container span {
            font-size: 1.2em;
            font-weight: 700;
            color: var(--primary-color);
            margin-left: 15px;
            vertical-align: middle;
        }

        main {
            flex-grow: 1;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
        }

        .screen { display: none; }
        .screen.active { display: block; }

        .card {
            background-color: #fff;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
        }

        h1, h2 { color: var(--primary-color); }
        p { line-height: 1.6; }

        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: #fff;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.3s, transform 0.2s;
            margin-top: 10px;
        }
        .btn:hover {
            background-color: #004488;
            transform: translateY(-2px);
        }
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        /* –°–∏—Å—Ç–µ–º–∞ –≤–∫–ª–∞–¥–æ–∫ */
        .tab-nav {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 25px;
        }
        .tab-btn {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1.1em;
            font-weight: 500;
            color: #666;
            position: relative;
            border-bottom: 3px solid transparent;
            transition: color 0.3s, border-color 0.3s;
        }
        .tab-btn:hover {
            color: var(--primary-color);
        }
        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* –≠–∫—Ä–∞–Ω –û—Å–º–æ—Ç—Ä–∞ */
        .inspection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .angle-slot {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s;
            position: relative;
            aspect-ratio: 4/3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .angle-slot::before {
            content: 'üì∑';
            font-size: 2em;
            color: var(--primary-color);
            margin-bottom: 8px;
            display: block;
            pointer-events: none;
        }
        .angle-slot:hover { border-color: var(--primary-color); }
        .angle-slot.active {
            border-color: var(--primary-color);
            border-style: solid;
            background-color: #f0f6ff;
        }
        .angle-slot.completed::before { content: ''; }
        .angle-slot.completed::after {
            content: '‚úî';
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--success-color);
            font-size: 1.5em;
            font-weight: bold;
        }
        .angle-slot img.preview, #single-photo-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }
        .remove-photo-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-photo-btn:hover { background: rgba(0,0,0,0.8); }

        #camera-area { margin-top: 20px; }
        .camera-container {
            position: relative;
            max-width: 640px;
            margin: auto;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        #video-feed {
            width: 100%;
            display: block;
        }
        .camera-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .camera-overlay svg {
            width: 80%;
            height: 80%;
            opacity: 0.4;
            stroke: #fff;
            stroke-width: 2px;
            fill: none;
        }

        #realtime-feedback {
            min-height: 24px;
            font-weight: bold;
            margin-top: 10px;
            transition: color 0.3s;
            color: var(--error-color);
        }

        .guidance {
            text-align: center;
            margin-top: 10px;
            font-weight: 500;
        }
        #tilt-indicator {
            display: inline-block;
            width: 100px;
            height: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            position: relative;
            background: linear-gradient(to right, var(--error-color), var(--success-color), var(--error-color));
        }
        #tilt-marker {
            position: absolute;
            top: -5px;
            left: 50%;
            width: 2px;
            height: 20px;
            background: var(--text-color);
            transform: translateX(-50%);
        }
        .camera-controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        #file-upload-label {
            cursor: pointer;
        }

        /* –ó–∞–≥—Ä—É–∑–∫–∞ –æ–¥–Ω–æ–≥–æ —Ñ–æ—Ç–æ */
        #single-photo-uploader {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            background-color: #fff;
            transition: border-color 0.3s, background-color 0.3s;
        }
        #single-photo-uploader:hover {
            border-color: var(--primary-color);
            background-color: #f8faff;
        }
        #single-photo-preview {
            margin-top: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        /* –≠–∫—Ä–∞–Ω –æ–±—Ä–∞–±–æ—Ç–∫–∏ */
        .loader {
            border: 8px solid var(--secondary-color);
            border-top: 8px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* –≠–∫—Ä–∞–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ */
        .results-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        @media (min-width: 768px) {
            .results-grid { grid-template-columns: 1fr 1fr; }
        }
        .result-item { margin-bottom: 20px; }
        .result-image-container {
            position: relative;
            margin-bottom: 15px;
        }
        .result-canvas {
            max-width: 100%;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        .result-list h3 { border-bottom: 2px solid var(--primary-color); padding-bottom: 10px; }
        .damage-item {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: left;
        }
        .damage-item:nth-child(odd) { background-color: var(--secondary-color); }
        .damage-item .part {
            font-weight: bold;
            color: var(--primary-color);
        }

        .hidden { display: none; }

        /* –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ */
        #error-message {
            display: none;
            background-color: var(--error-color);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
        }

        #svg-templates { width: 0; height: 0; overflow: hidden; position: absolute; }

        /* Modal for Zoom */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            visibility: visible;
            opacity: 1;
            transition: opacity 0.2s ease-in-out;
            pointer-events: auto;
        }
        .modal-overlay.hidden {
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 12px;
            position: relative;
            max-width: 90%;
            max-height: 90%;
            min-width: 300px;
            min-height: 300px;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 2.5em;
            font-weight: bold;
            color: #555;
            cursor: pointer;
        }
        .modal-close-btn:hover {
            color: #000;
        }
        #zoom-canvas {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo-container">
            <img src="https://centras.kz/wp-content/uploads/2023/12/centras-insurance-col-768x268.png" alt="–õ–æ–≥–æ—Ç–∏–ø –°–µ–Ω—Ç—Ä–∞—Å –ò–Ω—à—É—Ä–∞–Ω—Å" onerror="this.style.display='none'">
            <span>–°–µ–Ω—Ç—Ä–∞—Å –ò–Ω—à—É—Ä–∞–Ω—Å</span>
        </div>
        <nav style="margin-left: auto;">
            <a href="/index.html" style="margin-right: 20px; text-decoration: none; color: var(--primary-color); font-weight: 500;">–ê–Ω–∞–ª–∏–∑ –ø–æ —Ñ–æ—Ç–æ</a>
            <a href="/video.html" style="text-decoration: none; color: var(--primary-color); font-weight: 500;">–ê–Ω–∞–ª–∏–∑ –ø–æ –≤–∏–¥–µ–æ</a>
        </nav>
    </header>

    <main>
        <section id="screen-start" class="screen active">
            <div class="card">
                <h1>–û—Å–º–æ—Ç—Ä –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ –°—Ä–µ–¥—Å—Ç–≤–∞</h1>
                <p>–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π –¥–ª—è –≤–∞—Å —Å–ø–æ—Å–æ–± –æ—Å–º–æ—Ç—Ä–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—è. (–¥–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –∏ —Å–µ—Ä–≤–∏—Å —ç–∫—Å–ø–µ—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ - —ç—Ç–æ —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∑–∞–ø—Ä–µ—â–µ–Ω–æ)</p>
                <div class="tab-nav">
                    <button class="tab-btn active" data-tab="tab-multi-photo">–ü–æ—ç—Ç–∞–ø–Ω—ã–π –æ—Å–º–æ—Ç—Ä</button>
                    <button class="tab-btn" data-tab="tab-single-photo">–û—Å–º–æ—Ç—Ä –ø–æ 1 —Ñ–æ—Ç–æ</button>
                </div>

                <div id="tab-multi-photo" class="tab-content active">
                    <p>–°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≤–µ–¥–µ—Ç –≤–∞—Å —á–µ—Ä–µ–∑ 4 —à–∞–≥–∞ –¥–ª—è –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤–∞—à–µ–≥–æ –∞–≤—Ç–æ–º–æ–±–∏–ª—è. –ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å", —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.</p>
                    <button id="start-multi-btn" class="btn">–ù–∞—á–∞—Ç—å –ø–æ—ç—Ç–∞–ø–Ω—ã–π –æ—Å–º–æ—Ç—Ä</button>
                </div>

                <div id="tab-single-photo" class="tab-content">
                    <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–Ω—É —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –≤–∞—à–µ–≥–æ –∞–≤—Ç–æ–º–æ–±–∏–ª—è, –∏ –Ω–∞—à –ò–ò –ø—Ä–æ–≤–µ–¥–µ—Ç —ç–∫—Å–ø—Ä–µ—Å—Å-–∞–Ω–∞–ª–∏–∑ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π.</p>
                    <input type="file" id="single-file-input" accept="image/*" class="hidden">
                    <div id="single-photo-uploader">
                        <p>–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å —Ñ–∞–π–ª</p>
                    </div>
                    <div id="single-photo-preview"></div>
                    <button id="start-single-btn" class="btn" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –∞–Ω–∞–ª–∏–∑</button>
                </div>
            </div>
        </section>

        <section id="screen-inspection" class="screen">
            <h2>–®–∞–≥ 1: –°–¥–µ–ª–∞–π—Ç–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ 4 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏</h2>
            <p>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∫—É—Ä—Å, –Ω–∞–≤–µ–¥–∏—Ç–µ –∫–∞–º–µ—Ä—É —Å–æ–≥–ª–∞—Å–Ω–æ –ø–æ–¥—Å–∫–∞–∑–∫–µ –∏ —Å–¥–µ–ª–∞–π—Ç–µ —Ñ–æ—Ç–æ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∞–≤—Ç–æ–º–æ–±–∏–ª—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–º–µ—â–∞–µ—Ç—Å—è –≤ –∫–∞–¥—Ä.</p>

            <div class="inspection-grid">
                <div class="angle-slot" data-angle="front"><span>–í–∏–¥ —Å–ø–µ—Ä–µ–¥–∏</span></div>
                <div class="angle-slot" data-angle="rear"><span>–í–∏–¥ —Å–∑–∞–¥–∏</span></div>
                <div class="angle-slot" data-angle="left"><span>–õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞</span></div>
                <div class="angle-slot" data-angle="right"><span>–ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞</span></div>
            </div>

            <div id="camera-area" class="hidden card">
                <h3 id="camera-title"></h3>
                <div class="guidance">
                    –î–µ—Ä–∂–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω —Ä–æ–≤–Ω–æ:
                    <div id="tilt-indicator"><div id="tilt-marker"></div></div>
                    <div id="realtime-feedback"></div>
                </div>
                <div class="camera-container">
                    <video id="video-feed" playsinline autoplay muted></video>
                    <div id="camera-overlay" class="camera-overlay"></div>
                </div>
                <div class="camera-controls">
                    <button id="capture-btn" class="btn">–°–¥–µ–ª–∞—Ç—å —Ñ–æ—Ç–æ</button>
                    <label for="file-upload" class="btn btn-secondary">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</label>
                    <input type="file" id="file-upload" accept="image/*" class="hidden">
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="analyze-btn" class="btn" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –∞–Ω–∞–ª–∏–∑</button>
                 <button id="back-to-start-btn" class="btn btn-secondary">–ù–∞–∑–∞–¥</button>
            </div>
        </section>

        <section id="screen-processing" class="screen">
            <div class="card">
                <h2>–ê–Ω–∞–ª–∏–∑ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π</h2>
                <p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ. –ù–∞—à –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –¥–æ –æ–¥–Ω–æ–π –º–∏–Ω—É—Ç—ã.</p>
                <div class="loader"></div>
                 <p id="processing-status"></p>
            </div>
        </section>

        <section id="screen-results" class="screen">
            <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –û—Å–º–æ—Ç—Ä–∞</h2>
            <div id="error-message"></div>
            <p id="results-summary">–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è.</p>
            <div id="results-container"></div>
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="window.location.reload()" class="btn">–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –æ—Å–º–æ—Ç—Ä</button>
            </div>
        </section>
    </main>

    <div id="zoom-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <span class="modal-close-btn">&times;</span>
            <canvas id="zoom-canvas"></canvas>
        </div>
    </div>

    <div id="svg-templates">
        <svg id="svg-front" viewBox="0 0 100 60"><path d="M20 50 L10 40 L10 20 L20 10 L80 10 L90 20 L90 40 L80 50 Z M15 45 L15 15 L20 12 L80 12 L85 15 L85 45 L80 48 L20 48 Z M25 20h50v15H25z m-5 20h60v5H20z m5-25h5v-5h-5z m40 0h5v-5h-5z"></path></svg>
        <svg id="svg-rear" viewBox="0 0 100 60"><path d="M20 50 L10 40 L10 20 L20 10 L80 10 L90 20 L90 40 L80 50 Z M15 45 L15 15 L20 12 L80 12 L85 15 L85 45 L80 48 L20 48 Z M25 35h50v5H25z m-5-15h10v10H20z m50 0h10v10H70z"></path></svg>
        <svg id="svg-left" viewBox="0 0 120 60"><path d="M10 40 Q20 20 40 25 L80 20 L100 30 L110 40 L110 50 L10 50 Z M25 50 a5 5 0 1 0 10 0a5 5 0 1 0 -10 0 M85 50 a5 5 0 1 0 10 0 a5 5 0 1 0 -10 0"></path></svg>
        <svg id="svg-right" viewBox="0 0 120 60"><path d="M110 40 Q100 20 80 25 L40 20 L20 30 L10 40 L10 50 L110 50 Z M35 50 a5 5 0 1 0 -10 0a5 5 0 1 0 10 0 M95 50 a5 5 0 1 0 -10 0 a5 5 0 1 0 10 0"></path></svg>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    const appState = {
        currentAngle: null,
        photos: {
            front: null, rear: null, left: null, right: null,
        },
        singlePhoto: null,
        stream: null,
        model: null,
        isDetecting: false,
        isFramingGood: false,
        mode: 'multi' // 'multi' –∏–ª–∏ 'single'
    };

    // --- DOM –≠–ª–µ–º–µ–Ω—Ç—ã ---
    const screens = {
        start: document.getElementById('screen-start'),
        inspection: document.getElementById('screen-inspection'),
        processing: document.getElementById('screen-processing'),
        results: document.getElementById('screen-results'),
    };
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    const startMultiBtn = document.getElementById('start-multi-btn');
    const startSingleBtn = document.getElementById('start-single-btn');
    const analyzeBtn = document.getElementById('analyze-btn');
    const backToStartBtn = document.getElementById('back-to-start-btn');
    const angleSlots = document.querySelectorAll('.angle-slot');
    const cameraArea = document.getElementById('camera-area');
    const cameraTitle = document.getElementById('camera-title');
    const video = document.getElementById('video-feed');
    const cameraOverlay = document.getElementById('camera-overlay');
    const captureBtn = document.getElementById('capture-btn');
    const fileUpload = document.getElementById('file-upload');
    const tiltMarker = document.getElementById('tilt-marker');
    const singlePhotoUploader = document.getElementById('single-photo-uploader');
    const singleFileInput = document.getElementById('single-file-input');
    const singlePhotoPreview = document.getElementById('single-photo-preview');
    const resultsContainer = document.getElementById('results-container');
    const errorMessage = document.getElementById('error-message');
    const resultsSummary = document.getElementById('results-summary');
    const processingStatus = document.getElementById('processing-status');
    const realtimeFeedback = document.getElementById('realtime-feedback');
    const zoomModal = document.getElementById('zoom-modal');
    const zoomCanvas = document.getElementById('zoom-canvas');
    const closeModalBtn = document.querySelector('.modal-close-btn');

    // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–∞–ª—å–Ω—ã–º –æ–∫–Ω–æ–º ---
    closeModalBtn.addEventListener('click', () => zoomModal.classList.add('hidden'));
    zoomModal.addEventListener('click', (e) => {
        if (e.target === zoomModal) { // Click on overlay, not content
            zoomModal.classList.add('hidden');
        }
    });

    // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞–º–∏ –∏ –≤–∫–ª–∞–¥–∫–∞–º–∏ ---
    const showScreen = (screenName) => {
        Object.values(screens).forEach(s => s.classList.remove('active'));
        screens[screenName].classList.add('active');
    };

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const tabId = button.dataset.tab;
            tabContents.forEach(content => {
                content.classList.toggle('active', content.id === tabId);
            });
        });
    });

    // --- –ù–∞–≤–∏–≥–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ ---
    startMultiBtn.addEventListener('click', () => {
        appState.mode = 'multi';
        showScreen('inspection');
    });

    startSingleBtn.addEventListener('click', () => {
        if (!appState.singlePhoto) return;
        appState.mode = 'single';
        runAnalysis();
    });

    backToStartBtn.addEventListener('click', () => {
        resetState();
        showScreen('start');
    });

    // --- –õ–æ–≥–∏–∫–∞ –û—Å–º–æ—Ç—Ä–∞ –ø–æ 1 —Ñ–æ—Ç–æ ---
    singlePhotoUploader.addEventListener('click', () => singleFileInput.click());
    singleFileInput.addEventListener('change', handleSingleFile);

    function handleSingleFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            appState.singlePhoto = e.target.result;
            singlePhotoPreview.innerHTML = `<img src="${appState.singlePhoto}" alt="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ñ–æ—Ç–æ">`;
            startSingleBtn.disabled = false;
        };
        reader.readAsDataURL(file);
    }

    // --- –õ–æ–≥–∏–∫–∞ –ü–æ—ç—Ç–∞–ø–Ω–æ–≥–æ –æ—Å–º–æ—Ç—Ä–∞ ---
    angleSlots.forEach(slot => {
        slot.addEventListener('click', () => {
            appState.currentAngle = slot.dataset.angle;
            angleSlots.forEach(s => s.classList.remove('active'));
            slot.classList.add('active');
            const span = slot.querySelector('span');
            cameraTitle.textContent = span ? span.textContent : slot.textContent;
            cameraOverlay.innerHTML = document.getElementById(`svg-${appState.currentAngle}`).outerHTML;
            cameraArea.classList.remove('hidden');
            startCamera();
        });
    });

    // --- –õ–æ–≥–∏–∫–∞ –ö–∞–º–µ—Ä—ã –∏ —Ñ–∞–π–ª–æ–≤ ---
    const loadModel = async () => {
        if (appState.model) return;
        try {
            realtimeFeedback.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è...';
            console.log('Loading COCO-SSD model...');
            appState.model = await cocoSsd.load();
            console.log('Model loaded.');
            realtimeFeedback.textContent = '–ù–∞–≤–µ–¥–∏—Ç–µ –∫–∞–º–µ—Ä—É –Ω–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—å.';
        } catch (err) {
            console.error("Failed to load model", err);
            showErrorMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏.");
            realtimeFeedback.textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏.';
        }
    };

    const startCamera = async () => {
        await loadModel();
        try {
            if (appState.stream) {
                appState.stream.getTracks().forEach(track => track.stop());
            }
            const constraints = { video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } };
            appState.stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = appState.stream;
            video.addEventListener('play', () => {
                appState.isDetecting = true;
                runRealtimeDetection();
            });
        } catch (err) {
            console.error("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ: ", err);
        }
    };

    captureBtn.addEventListener('click', () => {
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
        processMultiPhoto(imageDataUrl);
    });

    fileUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => processMultiPhoto(e.target.result);
            reader.readAsDataURL(file);
        }
        event.target.value = null;
    });

    const processMultiPhoto = (imageDataUrl) => {
        appState.isDetecting = false;
        if (!appState.currentAngle) return;
        appState.photos[appState.currentAngle] = imageDataUrl;
        const slot = document.querySelector(`.angle-slot[data-angle="${appState.currentAngle}"]`);
        const angleText = slot.querySelector('span')?.textContent || slot.textContent;
        slot.innerHTML = `<button class="remove-photo-btn" aria-label="–£–¥–∞–ª–∏—Ç—å —Ñ–æ—Ç–æ">&times;</button><img src="${imageDataUrl}" class="preview" alt="${angleText}"><span style="display:none;">${angleText}</span>`;
        slot.classList.add('completed');
        const removeBtn = slot.querySelector('.remove-photo-btn');
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            appState.photos[slot.dataset.angle] = null;
            slot.innerHTML = `<span>${angleText}</span>`;
            slot.classList.remove('completed');
            analyzeBtn.disabled = Object.values(appState.photos).some(p => p === null);
        });
        cameraArea.classList.add('hidden');
        if (appState.stream) {
            appState.stream.getTracks().forEach(track => track.stop());
        }
        const allPhotosTaken = Object.values(appState.photos).every(p => p !== null);
        analyzeBtn.disabled = !allPhotosTaken;
    };

    const runRealtimeDetection = async () => {
        if (!appState.isDetecting || !appState.model || !video.srcObject) {
            requestAnimationFrame(runRealtimeDetection);
            return;
        }

        if (video.readyState >= 2) { // Check if video has enough data to play
            try {
                console.log("Calling model.detect()...");
                const predictions = await appState.model.detect(video);
                console.log("Predictions received:", predictions);
                handleDetections(predictions);
            } catch (err) {
                console.error("Error in model.detect():", err);
            }
        }

        requestAnimationFrame(runRealtimeDetection);
    };

    function handleDetections(predictions) {
        const car = predictions.find(p => p.class === 'car' && p.score > 0.6);

        if (!car) {
            realtimeFeedback.textContent = '–ê–≤—Ç–æ–º–æ–±–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω';
            realtimeFeedback.style.color = 'var(--error-color)';
            appState.isFramingGood = false;
            return;
        }

        const [x, y, width, height] = car.bbox;
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;

        const areaRatio = (width * height) / (videoWidth * videoHeight);
        const MIN_AREA = 0.3;
        const MAX_AREA = 0.9;

        if (areaRatio < MIN_AREA) {
            realtimeFeedback.textContent = '–ü–æ–¥–≤–∏–Ω—å—Ç–µ—Å—å –±–ª–∏–∂–µ';
            realtimeFeedback.style.color = 'var(--error-color)';
            appState.isFramingGood = false;
            return;
        }

        if (areaRatio > MAX_AREA) {
            realtimeFeedback.textContent = '–ü–æ–¥–≤–∏–Ω—å—Ç–µ—Å—å –¥–∞–ª—å—à–µ';
            realtimeFeedback.style.color = 'var(--error-color)';
            appState.isFramingGood = false;
            return;
        }

        const centerX = x + width / 2;
        const centerThreshold = videoWidth * 0.15;
        if (Math.abs(centerX - videoWidth / 2) > centerThreshold) {
            realtimeFeedback.textContent = '–û—Ç—Ü–µ–Ω—Ç—Ä—É–π—Ç–µ –∞–≤—Ç–æ–º–æ–±–∏–ª—å';
            realtimeFeedback.style.color = 'var(--error-color)';
            appState.isFramingGood = false;
            return;
        }

        // All checks passed for now. Clarity check can be added here.
        realtimeFeedback.textContent = '–û—Ç–ª–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–æ –∫ —Å—ä–µ–º–∫–µ';
        realtimeFeedback.style.color = 'var(--success-color)';
        appState.isFramingGood = true;
    }

    // --- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–∫–ª–æ–Ω–∞ ---
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (event) => {
            if (!event.gamma || cameraArea.classList.contains('hidden')) return;
            const gamma = event.gamma;
            let tilt = 50 + (gamma / 90) * 50;
            tilt = Math.max(0, Math.min(100, tilt));
            tiltMarker.style.left = `${tilt}%`;

            const isTiltOk = Math.abs(gamma) <= 5;

            if (appState.isFramingGood && isTiltOk) {
                captureBtn.disabled = false;
                captureBtn.style.backgroundColor = 'var(--success-color)';
            } else {
                captureBtn.disabled = true;
                captureBtn.style.backgroundColor = 'var(--primary-color)';
            }
        });
    }

    // --- –õ–æ–≥–∏–∫–∞ –ê–ù–ê–õ–ò–ó–ê ---
    analyzeBtn.addEventListener('click', runAnalysis);

    async function runAnalysis() {
        showScreen('processing');
        errorMessage.style.display = 'none';
        try {
            const photosToAnalyze = appState.mode === 'multi' ? appState.photos : { single: appState.singlePhoto };
            const results = await analyzeWithGemini(photosToAnalyze);
            displayResults(results);
            showScreen('results');
        } catch (error) {
            console.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –∞–Ω–∞–ª–∏–∑–∞:", error);
            showErrorMessage(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: ${error.message}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.`);
            showScreen('results');
        }
    }

    async function analyzeWithGemini(photos) {
        const apiUrl = '/.netlify/functions/analyze'; // The new endpoint
        let totalDamageCounter = 1;

        // Improved Prompt
        const prompt = `You are a world-class automotive damage assessment expert. Your task is to conduct a meticulous analysis of the provided car image. You must identify ALL defects, from major impacts to minor flaws like swirl marks or rock chips. For each identified defect, you must provide a detailed, structured report.

**Chain of Thought:**
1.  **Initial Scan:** Quickly scan the entire image to understand the context, lighting, and angle. Note any areas obscured by shadows, reflections, or dirt.
2.  **Systematic Decomposition:** Mentally divide the vehicle into standard parts (e.g., front bumper, hood, left front fender, left front door, etc.).
3.  **Sequential Analysis:** Examine each part methodically, as if using a magnifying glass.
4.  **Defect Identification & Segmentation:** For each defect, precisely outline its boundary with a polygon. Do NOT use simple boxes. The polygon must be tight and accurate.
5.  **Detailed Classification & Description:** Classify the defect and provide a rich, detailed description.
6.  **Critical Review:** Re-evaluate every identified defect. Is it truly damage or just a reflection? Is the polygon accurate? Is the description clear? Discard any findings you are not confident about.
7.  **Report Generation:** Only after this rigorous process, compile the final JSON array.

**STRICT OUTPUT REQUIREMENTS:**

Your response MUST be ONLY a JSON array. Do not add any text, comments, or markdown before or after the array. If no damage is found, return an empty array \`[]\`.

Each object in the array must have the following structure:
{
  "part": "STRING", // The specific car part (e.g., "Front Bumper", "Hood", "Left Front Door"). Be precise.
  "type": "STRING", // MUST be one of: "Dent", "Scratch", "Chip", "Crack", "Scuff", "Rust", "Other".
  "location": "STRING", // A brief description of the location ON THE PART (e.g., "upper right corner", "center, near the headlight", "along the bottom edge").
  "description": "STRING", // A DETAILED, expert description of the damage. For a scratch, specify length and depth (e.g., "Deep scratch, approx. 15cm long, appears to have penetrated the clear coat."). For a dent, describe its size and shape (e.g., "Shallow, round dent, approx. 5cm in diameter.").
  "confidence": "INTEGER", // Your confidence level (0-100). If < 95, explain why in the 'notes'.
  "notes": "STRING", // Optional: Mention any uncertainties (e.g., "Poor lighting in this area makes it hard to be certain.", "Could be a reflection, but appears to have depth.").
  "segmentation_polygon": [
    { "x": "FLOAT", "y": "FLOAT" }, // An array of {x, y} points outlining the damage. Values must be percentages of the image dimensions (0.0 to 100.0).
    ...
  ]
}`;

        processingStatus.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞...';

        const payload = {
            photos: photos,
            prompt: prompt
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            console.error('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞:', response.status, errorBody);
            try {
                const errorJson = JSON.parse(errorBody);
                throw new Error(`–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: ${errorJson.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
            } catch (e) {
                throw new Error(`–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ (—Å—Ç–∞—Ç—É—Å ${response.status}). –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏.`);
            }
        }

        const results = await response.json();

        // The server-side function now returns results with IDs, so we don't need to add them here.
        // We just need to update the processing status text.
        Object.keys(results).forEach(angle => {
             processingStatus.textContent = `–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è "${angle}" –ø–æ–ª—É—á–µ–Ω—ã.`;
        });

        return results;
    }

    // --- –õ–æ–≥–∏–∫–∞ –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ---
    const damageTypeColors = {
        "–í–º—è—Ç–∏–Ω–∞": "rgba(231, 76, 60, 0.6)",      // Red
        "–¶–∞—Ä–∞–ø–∏–Ω–∞": "rgba(241, 196, 15, 0.6)",   // Yellow
        "–°–∫–æ–ª": "rgba(52, 152, 219, 0.6)",       // Blue
        "–¢—Ä–µ—â–∏–Ω–∞": "rgba(155, 89, 182, 0.6)",    // Purple
        "–ü–æ—Ç–µ—Ä—Ç–æ—Å—Ç—å": "rgba(26, 188, 156, 0.6)", // Teal
        "–†–∂–∞–≤—á–∏–Ω–∞": "rgba(165, 42, 42, 0.6)",    // Brown
        "–î—Ä—É–≥–æ–µ": "rgba(149, 165, 166, 0.6)",    // Grey
        "default": "rgba(243, 156, 18, 0.6)"     // Orange
    };

    function drawZoomedDamage(imageUrl, damage) {
        console.log(`drawZoomedDamage called for damage ID: ${damage.id}`);
        const img = new Image();
        img.onerror = (err) => {
            console.error("Error loading image for zoom canvas:", err);
        };
        img.onload = () => {
            console.log(`Image loaded for zoom. Drawing now.`);
            // Calculate bounding box from polygon
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            damage.segmentation_polygon.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            // Add some padding to the bounding box
            const paddingWidth = (maxX - minX) * 0.2; // 20% padding
            const paddingHeight = (maxY - minY) * 0.2;

            const sx = Math.max(0, (minX / 100) * img.width - paddingWidth);
            const sy = Math.max(0, (minY / 100) * img.height - paddingHeight);
            const sWidth = ((maxX - minX) / 100) * img.width + paddingWidth * 2;
            const sHeight = ((maxY - minY) / 100) * img.height + paddingHeight * 2;

            zoomCanvas.width = sWidth;
            zoomCanvas.height = sHeight;

            const zCtx = zoomCanvas.getContext('2d');
            zCtx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, zoomCanvas.width, zoomCanvas.height);

            zoomModal.classList.remove('hidden');
            zoomModal.dataset.status = 'ready';
        };
        img.src = imageUrl;
    }

    function displayResults(results) {
        resultsContainer.innerHTML = '';
        let totalDamages = 0;
        for (const angle in results) {
            if ((appState.mode === 'multi' && appState.photos[angle]) || (appState.mode === 'single' && appState.singlePhoto)) {
                totalDamages += results[angle].length;
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                const title = document.createElement('h3');
                const angleText = appState.mode === 'multi' ? (document.querySelector(`.angle-slot[data-angle=${angle}] span`)?.textContent || '–§–æ—Ç–æ') : '–†–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞';
                title.textContent = `${angleText} (${results[angle].length} –ø–æ–≤—Ä.)`;
                const imageContainer = document.createElement('div');
                imageContainer.className = 'result-image-container';
                const canvas = document.createElement('canvas');
                canvas.className = 'result-canvas';
                imageContainer.appendChild(canvas);
                resultItem.appendChild(title);
                resultItem.appendChild(imageContainer);
                const damageList = document.createElement('div');
                if (results[angle].length > 0) {
                    results[angle].forEach(damage => {
                        const p = document.createElement('p');
                        p.className = 'damage-item';
                        p.style.cursor = 'pointer';

                        let damageTitle = `<strong>#${damage.id} ${damage.part || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –¥–µ—Ç–∞–ª—å'}</strong> - ${damage.type || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø'}`;
                        let damageLocation = `<div style="font-style: italic; color: #555; margin-top: 4px;"><strong>–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ:</strong> ${damage.location || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}</div>`;
                        let damageDescription = `<div style="margin-top: 6px;"><strong>–û–ø–∏—Å–∞–Ω–∏–µ:</strong> ${damage.description || '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}</div>`;
                        let damageConfidence = '';
                        if (damage.confidence < 95) {
                            damageConfidence = `<div style="margin-top: 6px; color: #D35400;"><strong>–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${damage.confidence}%</strong>. –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: ${damage.notes || '–ù–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å'}</div>`;
                        }

                        p.innerHTML = damageTitle + damageLocation + damageDescription + damageConfidence;

                        p.addEventListener('click', () => {
                            console.log(`Click event fired for damage ID: ${damage.id}`);
                            const imageUrl = appState.mode === 'multi' ? appState.photos[angle] : appState.singlePhoto;
                            drawZoomedDamage(imageUrl, damage);
                        });

                        damageList.appendChild(p);
                    });
                } else {
                    damageList.innerHTML = '<p>–ü–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.</p>';
                }
                resultItem.appendChild(damageList);
                let lastGrid = resultsContainer.querySelector('.results-grid:last-child');
                if (!lastGrid || (window.innerWidth >= 768 && lastGrid.children.length >= 2)) {
                    lastGrid = document.createElement('div');
                    lastGrid.className = 'results-grid';
                    resultsContainer.appendChild(lastGrid);
                }
                lastGrid.appendChild(resultItem);
                const imageUrl = appState.mode === 'multi' ? appState.photos[angle] : appState.singlePhoto;
                drawOnCanvas(canvas, imageUrl, results[angle]);
            }
        }
        if (totalDamages === 0) {
            resultsSummary.style.display = 'none';
            resultsContainer.innerHTML = `<div class="card"><p style="color: var(--success-color); font-weight: bold; font-size: 1.2em;">–û—Ç–ª–∏—á–Ω–æ! –í —Ö–æ–¥–µ –∞–Ω–∞–ª–∏–∑–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π –Ω–µ –±—ã–ª–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ.</p></div>`;
        } else {
            resultsSummary.textContent = `–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π: ${totalDamages}.`;
            resultsSummary.style.display = 'block';
        }
    }

    function drawOnCanvas(canvas, imageUrl, damages) {
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            ctx.drawImage(img, 0, 0);

            damages.forEach(damage => {
                if (!damage.segmentation_polygon || damage.segmentation_polygon.length < 3) return;
                const polygon = damage.segmentation_polygon;

                const color = damageTypeColors[damage.type] || damageTypeColors.default;

                // --- Enhanced Highlighting ---
                ctx.save(); // Save the current state

                // 1. Create the polygon path
                ctx.beginPath();
                ctx.moveTo((polygon[0].x / 100) * img.width, (polygon[0].y / 100) * img.height);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo((polygon[i].x / 100) * img.width, (polygon[i].y / 100) * img.height);
                }
                ctx.closePath();

                // 2. Draw the "glow" effect (a thick, semi-transparent white stroke)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.lineWidth = Math.max(12, img.width / 70); // Thicker line for glow
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();

                // 3. Draw the colored fill
                ctx.fillStyle = color;
                ctx.fill();

                // 4. Draw a thinner, solid border on top for definition
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = Math.max(2, img.width / 400);
                ctx.stroke();

                ctx.restore(); // Restore to the original state (before path clipping)

                // 5. Draw the numbered label
                let sumX = 0, sumY = 0;
                polygon.forEach(p => { sumX += p.x; sumY += p.y; });
                const centerX = (sumX / polygon.length / 100) * img.width;
                const centerY = (sumY / polygon.length / 100) * img.height;

                const fontSize = Math.max(18, img.width / 40);
                ctx.font = `bold ${fontSize}px Arial, sans-serif`;
                const text = damage.id.toString();
                const textMetrics = ctx.measureText(text);

                // Draw a background for the text
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, textMetrics.width, 0, 2 * Math.PI);
                ctx.fill();

                // Draw the text
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, centerX, centerY + 1); // Small offset for better centering
            });
        };
        img.src = imageUrl;
    }

    function showErrorMessage(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
    }

    function resetState() {
        appState.isDetecting = false;
        appState.currentAngle = null;
        appState.photos = { front: null, rear: null, left: null, right: null };
        appState.singlePhoto = null;
        appState.mode = 'multi';
        if (appState.stream) {
            appState.stream.getTracks().forEach(track => track.stop());
            appState.stream = null;
        }
        angleSlots.forEach(slot => {
            const angle = slot.dataset.angle;
            const angleText = {front: '–í–∏–¥ —Å–ø–µ—Ä–µ–¥–∏', rear: '–í–∏–¥ —Å–∑–∞–¥–∏', left: '–õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞', right: '–ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞'}[angle];
            slot.innerHTML = `<span>${angleText}</span>`;
            slot.classList.remove('completed', 'active');
        });
        singlePhotoPreview.innerHTML = '';
        startSingleBtn.disabled = true;
        analyzeBtn.disabled = true;
        errorMessage.style.display = 'none';
        resultsContainer.innerHTML = '';
        tabButtons.forEach((btn, index) => btn.classList.toggle('active', index === 0));
        tabContents.forEach((content, index) => content.classList.toggle('active', index === 0));
    }

    // Expose functions for testing
    window.appState = appState;
    window.showScreen = showScreen;
    window.displayResults = displayResults;
});
</script>
</body>
</html>
